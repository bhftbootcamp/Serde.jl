var documenterSearchIndex = {"docs":
[{"location":"pages/xml/#XML","page":"XML","title":"XML","text":"","category":"section"},{"location":"pages/xml/#Parsing","page":"XML","title":"Parsing","text":"","category":"section"},{"location":"pages/xml/","page":"XML","title":"XML","text":"Serde.parse_xml\nSerde.XmlSyntaxError","category":"page"},{"location":"pages/xml/#Serde.ParXml.parse_xml","page":"XML","title":"Serde.ParXml.parse_xml","text":"parse_xml(x::AbstractString; kw...) -> Dict{String,Any}\nparse_xml(x::Vector{UInt8}; kw...) -> Dict{String,Any}\n\nParse an XML string x (or vector of UInt8) into a dictionary.\n\nKeyword arguments\n\ndict_type::Type{<:AbstractDict} = Dict: The type of the dictionary to be returned.\n\nExamples\n\njulia> xml = \"\"\"\n           <book id=\"bk101\">\n              <title>Advanced Julia Programming</title>\n              <authors>\n                  <author lang=\"en\">John Doe</author>\n                  <author lang=\"es\">Juan Pérez</author>\n              </authors>\n              <year>2024</year>\n              <price>49.99</price>\n           </book>\n       \"\"\"\n\njulia> parse_xml(xml)\nDict{String, Any} with 5 entries:\n  \"price\"   => Dict{String, Any}(\"_\"=>\"49.99\")\n  \"year\"    => Dict{String, Any}(\"_\"=>\"2024\")\n  \"id\"      => \"bk101\"\n  \"title\"   => Dict{String, Any}(\"_\"=>\"Advanced Julia Programming\")\n  \"authors\" => Dict{String, Any}(\"author\"=>Dict{String, Any}[Dict(\"lang\"=>\"en\", \"_\"=>\"John Doe\"), Dict(\"lang\"=>\"es\", \"_\"=>\"Juan Pérez\")])\n\n\n\n\n\n","category":"function"},{"location":"pages/xml/#Serde.ParXml.XmlSyntaxError","page":"XML","title":"Serde.ParXml.XmlSyntaxError","text":"XmlSyntaxError <: Exception\n\nException thrown when a parse_xml fails due to incorrect XML syntax or any underlying error that occurs during parsing.\n\nFields\n\nmessage::String: The error message.\nexception::Exception: The exception that was caught.\n\n\n\n\n\n","category":"type"},{"location":"pages/xml/#Deserialization","page":"XML","title":"Deserialization","text":"","category":"section"},{"location":"pages/xml/","page":"XML","title":"XML","text":"Serde.deser_xml","category":"page"},{"location":"pages/xml/#Serde.DeXml.deser_xml","page":"XML","title":"Serde.DeXml.deser_xml","text":"deser_xml(::Type{T}, x; kw...) -> T\n\nCreates a new object of type T and fill it with values from XML formated string x (or vector of UInt8).\n\nKeyword arguments kw is the same as in parse_xml.\n\nExamples\n\njulia> struct Record\n           count::Float64\n       end\n\njulia> struct Data\n           id::Int64\n           name::String\n           body::Record\n       end\n\njulia> xml = \"\"\"\n       <root>\n           <id>100</id>\n           <name>xml</name>\n           <body>\n               <count>100.0</count>\n           </body>\n       </root>\n       \"\"\";\n\njulia> deser_xml(Data, xml)\nData(100, \"xml\", Record(100.0))\n\n\n\n\n\n","category":"function"},{"location":"pages/xml/#Serialization","page":"XML","title":"Serialization","text":"","category":"section"},{"location":"pages/xml/","page":"XML","title":"XML","text":"Serde.to_xml","category":"page"},{"location":"pages/xml/#Serde.SerXml.to_xml","page":"XML","title":"Serde.SerXml.to_xml","text":"to_xml(val; key::String = \"xml\") -> String\n\nSerializes any nested data val into an XML string that follows the next rules:\n\nValues of primitive types are used as an element of the current tag.\nVector elements will be used as sub-tag elements.\nDictionaries are processed using the following rules:\nKey names must be a string or a symbol types.\nA key with a non-empty string value will be interpreted as a new sub-tag.\nA key with an empty string value will be interpreted as an element of the current tag.\nCustom types are handled as follows:\nThe field name containing the primitive type will be used as an attribute for the current tag.\nA field name containing a composite type (dictionary or other custom type) will be used as the name for the next sub-tag.\nA primitive type field with a special name \"_\" will be used as an element for the current tag.\n\nThus, this method can serialize all basic data types and can work with any nesting level of a combination of dictionaries and custom data types. The key keyword specifies the name of the root tag.\n\nExamples\n\njulia> struct Image\n           dpi::Int64\n           _::String\n       end\n\njulia> struct Data\n           info::Dict\n           image::Image\n       end\n\njulia> data_info = Dict(\"id\" => \"451\", \"status\" => \"OK\", \"_\" => \"employee\");\n\njulia> to_xml(Data(data_info, Image(200, \"profile.png\"))) |> print\n<xml>\n  <image dpi=\"200\">profile.png</image>\n  <info status=\"OK\" id=\"451\">employee</info>\n</xml>\n\n\n\n\n\n","category":"function"},{"location":"pages/csv/#CSV","page":"CSV","title":"CSV","text":"","category":"section"},{"location":"pages/csv/#Parsing","page":"CSV","title":"Parsing","text":"","category":"section"},{"location":"pages/csv/","page":"CSV","title":"CSV","text":"Serde.parse_csv\nSerde.CSVSyntaxError","category":"page"},{"location":"pages/csv/#Serde.ParCsv.parse_csv","page":"CSV","title":"Serde.ParCsv.parse_csv","text":"parse_csv(x::AbstractString; kw...) -> Vector{NamedTuple}\nparse_csv(x::Vector{UInt8}; kw...) -> Vector{NamedTuple}\n\nParse a CSV string x (or vector of UInt8) into a vector of dictionaries, where keys are column names and values are corresponding cell values.\n\nKeyword arguments\n\ndelimiter::AbstractString = \",\": The delimiter that will be used in the parsed csv string.\nOther keyword arguments can be found in CSV.File\n\nExamples\n\njulia> csv = \"\"\"\n       \"id\",\"name\",\"grade\"\n       1,\"Fred\",78.2\n       2,\"Benny\",82.0\n       \"\"\";\n\njulia> parse_csv(csv)\n2-element Vector{NamedTuple{(:id, :name, :grade), Tuple{String, String, String}}}:\n (id = \"1\", name = \"Fred\", grade = \"78.2\")\n (id = \"2\", name = \"Benny\", grade = \"82.0\")\n\n\n\n\n\n","category":"function"},{"location":"pages/csv/#Serde.ParCsv.CSVSyntaxError","page":"CSV","title":"Serde.ParCsv.CSVSyntaxError","text":"CSVSyntaxError <: Exception\n\nException thrown when a parse_csv fails due to incorrect CSV syntax or any underlying error that occurs during parsing.\n\nFields\n\nmessage::String: The error message.\nexception::Exception: The catched exception.\n\n\n\n\n\n","category":"type"},{"location":"pages/csv/#Deserialization","page":"CSV","title":"Deserialization","text":"","category":"section"},{"location":"pages/csv/","page":"CSV","title":"CSV","text":"Serde.deser_csv","category":"page"},{"location":"pages/csv/#Serde.DeCsv.deser_csv","page":"CSV","title":"Serde.DeCsv.deser_csv","text":"deser_csv(::Type{T}, x; kw...) -> Vector{T}\n\nCreates a new object of type T and fill it with values from CSV formated string x (or vector of UInt8).\n\nKeyword arguments kw is the same as in parse_csv.\n\nExamples\n\njulia> struct Data\n           id::Int64\n           name::String\n           grade::Float64\n       end\n\njulia> csv = \"\"\"\n       \"id\",\"name\",\"grade\"\n       1,\"Fred\",78.2\n       2,\"Benny\",82.0\n       \"\"\";\n\njulia> deser_csv(Data, csv)\n2-element Vector{Data}:\n Data(1, \"Fred\", 78.2)\n Data(2, \"Benny\", 82.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/csv/#Serialization","page":"CSV","title":"Serialization","text":"","category":"section"},{"location":"pages/csv/","page":"CSV","title":"CSV","text":"Serde.to_csv","category":"page"},{"location":"pages/csv/#Serde.SerCsv.to_csv","page":"CSV","title":"Serde.SerCsv.to_csv","text":"to_csv(data::Vector{T}; kw...) -> String\n\nUses data element values to make csv rows with fieldnames as columns headers. Type T may be a nested dictionary or a custom type. In case of nested data, names of resulting headers will be concatenate by \"_\" symbol using dictionary key-names or structure field names.\n\nKeyword arguments\n\ndelimiter::String = \",\": The delimiter that will be used in the returned csv string.\nheaders::Vector{String} = String[]: Specifies which column headers will be used and in what order.\nwith_names::Bool = true: Determines if column headers are included in the CSV output (true to include, false to exclude).\n\nExamples\n\nConverting a vector of regular dictionaries with fixed headers order.\n\njulia> data = [\n           Dict(\"id\" => 1, \"name\" => \"Jack\"),\n           Dict( \"id\" => 2, \"name\" => \"Bob\"),\n       ];\n\njulia> to_csv(data, headers = [\"name\", \"id\"]) |> print\nname,id\nJack,1\nBob,2\n\nConverting a vector of nested dictionaries with custom separator symbol.\n\njulia> data = [\n           Dict(\n               \"level\" => 1,\n               \"sub\" => Dict(\n                   \"level\" => 2,\n                   \"sub\" => Dict(\n                       \"level\" => 3\n                   ),\n               ),\n           ),\n           Dict(:level => 1),\n       ];\n\njulia> to_csv(data, separator = \"|\") |> print\nlevel|sub_level|sub_sub_level\n1|2|3\n1||\n\nConverting a vector of custom structures.\n\njulia> struct Foo\n           val::Int64\n           str::String\n       end\n\njulia> data = [Foo(1, \"a\"), Foo(2, \"b\")]\n2-element Vector{Foo}:\n Foo(1, \"a\")\n Foo(2, \"b\")\n\njulia> to_csv(data) |> print\nstr,val\na,1\nb,2\n\n\n\n\n\n","category":"function"},{"location":"pages/query/#Query","page":"Query","title":"Query","text":"","category":"section"},{"location":"pages/query/#Parsing","page":"Query","title":"Parsing","text":"","category":"section"},{"location":"pages/query/","page":"Query","title":"Query","text":"Serde.parse_query\nSerde.QuerySyntaxError","category":"page"},{"location":"pages/query/#Serde.ParQuery.parse_query","page":"Query","title":"Serde.ParQuery.parse_query","text":"parse_query(x::AbstractString; kw...) -> Dict{String, Union{String, Vector{String}}}\nparse_query(x::Vector{UInt8}; kw...) -> Dict{String, Union{String, Vector{String}}}\n\nParses a query string x (or vector of UInt8) into a dictionary.\n\nKeyword arguments\n\nbackbone::Type = Nothing: The custom type that describes types of query elements.\ndelimiter::AbstractString = \"&\": The delimiter of query string.\ndict_type::Type{<:AbstractDict} = Dict: The type of the dictionary to be returned.\n\nExamples\n\njulia> struct Template\n           vector::Vector\n           value::String\n       end\n\njulia> query = \"value=abc&vector=[1,2,3]\"\n\njulia> parse_query(query)\nDict{String, Union{String, Vector{String}}} with 2 entries:\n  \"vector\" => \"[1,2,3]\"\n  \"value\"  => \"abc\"\n\njulia> parse_query(query, backbone = Template)\nDict{String, Union{String, Vector{String}}} with 2 entries:\n  \"vector\" => [\"1\", \"2\", \"3\"]\n  \"value\"  => \"abc\"\n\n\n\n\n\n","category":"function"},{"location":"pages/query/#Serde.ParQuery.QuerySyntaxError","page":"Query","title":"Serde.ParQuery.QuerySyntaxError","text":"QuerySyntaxError <: Exception\n\nException thrown when a parse_query fails due to incorrect query syntax or any underlying error that occurs during parsing.\n\nFields\n\nmessage::String: The error message.\nexception::Exception: The caught exception.\n\n\n\n\n\n","category":"type"},{"location":"pages/query/#Deserialization","page":"Query","title":"Deserialization","text":"","category":"section"},{"location":"pages/query/","page":"Query","title":"Query","text":"Serde.deser_query","category":"page"},{"location":"pages/query/#Serde.DeQuery.deser_query","page":"Query","title":"Serde.DeQuery.deser_query","text":"deser_query(::Type{T}, x; kw...) -> T\n\nCreates a new object of type T and fill it with values from Query formated string x (or vector of UInt8).\n\nKeyword arguments kw is the same as in parse_query.\n\nExamples\n\njulia> struct Person\n           age::Int64\n           name::String\n           pets::Vector{String}\n       end\n\njulia> query = \"age=20&name=Nancy&pets=[Cat,Dog]\";\n\njulia> deser_query(Person, query)\nPerson(20, \"Nancy\", [\"Cat\", \"Dog\"])\n\n\n\n\n\n","category":"function"},{"location":"pages/query/#Serealization","page":"Query","title":"Serealization","text":"","category":"section"},{"location":"pages/query/","page":"Query","title":"Query","text":"Serde.to_query","category":"page"},{"location":"pages/query/#Serde.SerQuery.to_query","page":"Query","title":"Serde.SerQuery.to_query","text":"to_query(data; kw...) -> String\n\nConverts dictionary data (or custom type) to the query string. Values of data must be of primitive types or a vector of such. In case of custom data, the names of the query elements are obtained from the field names of data.\n\nKeyword arguments\n\ndelimiter::AbstractString = \"&\": The separator character between query string elements.\nsort_keys::Bool = false: A flag that determines whether the keys should be sorted by lexicographic order.\nescape::Bool = true: Option to construct a valid URI-encoded string.\n\nExamples\n\njulia> struct Data\n           int::Int64\n           float::Float64\n           strings::Vector{String}\n       end\n\njulia> to_query(Data(1, 2.0, [\"a\", \"b\", \"c\"]), sort_keys=true)\n\"float=2.0&int=1&strings=%5Ba%2Cb%2Cc%5D\"\n\njulia> to_query(Data(1, 2.0, [\"a\", \"b\", \"c\"]), escape = false)\n\"int=1&float=2.0&strings=[a,b,c]\"\n\njulia> data = Dict(\n           \"int\" => 1,\n           \"float\" => 2.0,\n           \"strings\" => [\"a\", \"b\", \"c\"]\n       );\n\njulia> to_query(data, escape = false)\n\"int=1&strings=[a,b,c]&float=2.0\"\n\n\n\n\n\n","category":"function"},{"location":"pages/toml/#TOML","page":"TOML","title":"TOML","text":"","category":"section"},{"location":"pages/toml/#Parsing","page":"TOML","title":"Parsing","text":"","category":"section"},{"location":"pages/toml/","page":"TOML","title":"TOML","text":"Serde.parse_toml\nSerde.TomlSyntaxError","category":"page"},{"location":"pages/toml/#Serde.ParToml.parse_toml","page":"TOML","title":"Serde.ParToml.parse_toml","text":"parse_toml(x::AbstractString) -> Dict{String,Any}\nparse_toml(x::Vector{UInt8}) -> Dict{String,Any}\n\nParses a TOML string x (or vector of UInt8) into a dictionary.\n\nExamples\n\njulia> toml = \"\"\"\n       tag = \"line\"\n       [[points]]\n       x = 1\n       y = 0\n       [[points]]\n       x = 2\n       y = 3\n       \"\"\";\n\njulia> parse_toml(toml)\nDict{String, Any} with 3 entries:\n  \"tag\"  => \"line\"\n  \"points\" => Any[Dict{String, Any}(\"y\"=>0, \"x\"=>1), Dict{String, Any}(\"y\"=>3, \"x\"=>2)]\n\n\n\n\n\n","category":"function"},{"location":"pages/toml/#Serde.ParToml.TomlSyntaxError","page":"TOML","title":"Serde.ParToml.TomlSyntaxError","text":"TomlSyntaxError <: Exception\n\nException thrown when a parse_toml fails due to incorrect TOML syntax or any underlying error that occurs during parsing.\n\nFields\n\nmessage::String: The error message.\nexception::Exception: The catched exception.\n\n\n\n\n\n","category":"type"},{"location":"pages/toml/#Deserialization","page":"TOML","title":"Deserialization","text":"","category":"section"},{"location":"pages/toml/","page":"TOML","title":"TOML","text":"Serde.deser_toml","category":"page"},{"location":"pages/toml/#Serde.DeToml.deser_toml","page":"TOML","title":"Serde.DeToml.deser_toml","text":"deser_toml(::Type{T}, x) -> T\n\nCreates a new object of type T and fill it with values from TOML formated string x (or vector of UInt8).\n\nSee also parse_toml.\n\nExamples\n\njulia> struct Point\n           x::Int64\n           y::Int64\n       end\n\njulia> struct MyPlot\n           tag::String\n           points::Vector{Point}\n       end\n\njulia> toml = \"\"\"\n       tag = \"line\"\n       [[points]]\n       x = 1\n       y = 0\n       [[points]]\n       x = 2\n       y = 3\n       \"\"\";\n\njulia> deser_toml(MyPlot, toml)\nMyPlot(\"line\", Point[Point(1, 0), Point(2, 3)])\n\n\n\n\n\n","category":"function"},{"location":"pages/toml/#Serialization","page":"TOML","title":"Serialization","text":"","category":"section"},{"location":"pages/toml/","page":"TOML","title":"TOML","text":"Serde.to_toml","category":"page"},{"location":"pages/toml/#Serde.SerToml.to_toml","page":"TOML","title":"Serde.SerToml.to_toml","text":"to_toml(data) -> String\n\nPasses a dictionary data (or custom data structure) for making TOML string.\n\nExamples\n\nMake TOML string from nested dictionaries.\n\njulia> data = Dict(\n           \"points\" => [\n               Dict(\"x\" => \"100\", \"y\" => 200),\n               Dict(\"x\" => 300, \"y\" => 400),\n           ],\n           \"data\" => Dict(\"id\" => 321, \"price\" => 600),\n           \"answer\" => 42,\n       );\n\njulia> to_toml(data) |> println\nanswer = 42\n\n[data]\nprice = 600\nid = 321\n\n[[points]]\ny = 200\nx = \"100\"\n\n[[points]]\ny = 400\nx = 300\n\nMake TOML string from custom data structures.\n\njulia> struct Point\n           x::Int64\n           y::Int64\n       end\n\njulia> struct MyPlot\n           tag::String\n           points::Vector{Point}\n       end\n\njulia> myline = MyPlot(\"line\", Point[Point(1, 0), Point(2, 3)]);\n\njulia> to_toml(myline) |> println\ntag = \"line\"\n\n[[points]]\nx = 1\ny = 0\n\n[[points]]\nx = 2\ny = 3\n\n\n\n\n\n","category":"function"},{"location":"pages/json/#JSON","page":"JSON","title":"JSON","text":"","category":"section"},{"location":"pages/json/#Parsing","page":"JSON","title":"Parsing","text":"","category":"section"},{"location":"pages/json/","page":"JSON","title":"JSON","text":"Serde.parse_json\nSerde.JsonSyntaxError","category":"page"},{"location":"pages/json/#Serde.ParJson.parse_json","page":"JSON","title":"Serde.ParJson.parse_json","text":"parse_json(x::AbstractString; kw...) -> Dict{String,Any}\nparse_json(x::Vector{UInt8}; kw...) -> Dict{String,Any}\n\nParse a JSON string x (or vector of UInt8) into a dictionary.\n\nKeyword arguments\n\nYou can see additional keyword arguments in JSON.jl package documentation.\n\nExamples\n\njulia> json = \"\"\"\n        {\n            \"number\": 123,\n            \"vector\": [1, 2, 3],\n            \"dictionary\":\n            {\n                \"string\": \"123\"\n            }\n        }\n       \"\"\";\n\njulia> parse_json(json)\nDict{String, Any} with 3 entries:\n  \"number\"     => 123\n  \"vector\"     => Any[1, 2, 3]\n  \"dictionary\" => Dict{String, Any}(\"string\"=>\"123\")\n\n\n\n\n\n","category":"function"},{"location":"pages/json/#Serde.ParJson.JsonSyntaxError","page":"JSON","title":"Serde.ParJson.JsonSyntaxError","text":"JsonSyntaxError <: Exception\n\nException thrown when a parse_json fails due to incorrect JSON syntax or any underlying error that occurs during parsing.\n\nFields\n\nmessage::String: The error message.\nexception::Exception: The catched exception.\n\n\n\n\n\n","category":"type"},{"location":"pages/json/#Deserialization","page":"JSON","title":"Deserialization","text":"","category":"section"},{"location":"pages/json/","page":"JSON","title":"JSON","text":"Serde.deser_json","category":"page"},{"location":"pages/json/#Serde.DeJson.deser_json","page":"JSON","title":"Serde.DeJson.deser_json","text":"deser_json(::Type{T}, x; kw...) -> T\n\nCreates a new object of type T and fill it with values from JSON formated string x (or vector of UInt8).\n\nKeyword arguments kw is the same as in parse_json.\n\nExamples\n\njulia> struct Record\n           count::Float64\n       end\n\njulia> struct Data\n           id::Int64\n           name::String\n           body::Record\n       end\n\njulia> json = \"\"\" {\"body\":{\"count\":100.0},\"name\":\"json\",\"id\":100} \"\"\";\n\njulia> deser_json(Data, json)\nData(100, \"json\", Record(100.0))\n\n\n\n\n\n","category":"function"},{"location":"pages/json/#Serialization","page":"JSON","title":"Serialization","text":"","category":"section"},{"location":"pages/json/","page":"JSON","title":"JSON","text":"Serde.to_json\nSerde.to_pretty_json","category":"page"},{"location":"pages/json/#Serde.SerJson.to_json","page":"JSON","title":"Serde.SerJson.to_json","text":"to_json([f::Function], data) -> String\n\nSerializes any data into a flat JSON string. This method support serialization of nested data like dictionaries or custom types.\n\nSpecifying fields for serialization\n\nIf you want to serialize only specific fields of some custom type, you may define a special function f. This function f must lead next signature:\n\nf(::Type{CustomType}) = (:field_1, :field_2, ...)\n\nNow to_json(f, CustomType(...)) will serialize only specified fields CustomType.field_1, CustomType.field_2, etc. You can also define multiple methods of f for nested custom data types, e.g:\n\n# Custom type 'Foo' containing fields of other custom types 'bar::Bar' and 'baz::Baz'\ncustom_field_names(::Type{Foo}) = (:bar, :baz, ...)\n\n# Another custom types\ncustom_field_names(::Type{Bar}) = (:data, ...)\ncustom_field_names(::Type{Baz}) = (:another_data, ...)\n\nSee also to_pretty_json.\n\nExamples\n\njulia> struct Pet\n           name::String\n           age::Int64\n       end\n\njulia> struct Person\n           info::Dict{String,Any}\n           pet::Pet\n       end\n\njulia> person_info = Dict(\"id\" => 42, \"marks\" => [\"A+\", \"B\", \"A\"]);\n\njulia> to_json(Person(person_info, Pet(\"Buddy\", 5))) |> print\n{\"info\":{\"marks\":[\"A+\",\"B\",\"A\"],\"id\":42},\"pet\":{\"name\":\"Buddy\",\"age\":5}}\n\nNow, lets select some specific fields from custom type\n\njulia> struct ManyFields\n           field::Int64\n           another_field::Float64\n           simple_field::String\n           fld::Vector{Bool}\n       end\n\njulia> custom_field_names(::Type{ManyFields}) = (:field, :simple_field)\n\njulia> to_json(custom_field_names, ManyFields(1, 2.0, \"a\", [true, false])) |> print\n{\"field\":1,\"simple_field\":\"a\"}\n\n# Or you can use a lambda function\n\njulia> to_json(x -> (:field, :simple_field), ManyFields(1, 2.0, \"a\", [true, false])) |> print\n{\"field\":1,\"simple_field\":\"a\"}\n\n\n\n\n\n","category":"function"},{"location":"pages/json/#Serde.SerJson.to_pretty_json","page":"JSON","title":"Serde.SerJson.to_pretty_json","text":"to_pretty_json([f::Function], data) -> String\n\nDo the same as to_json but return pretty JSON string.\n\njulia> struct Pet\n           name::String\n           age::Int64\n       end\n\njulia> struct Person\n           info::Dict{String,Any}\n           pet::Pet\n       end\n\njulia> person_info = Dict(\"id\" => 42, \"marks\" => [\"A+\", \"B\", \"A\"]);\n\njulia> to_pretty_json(Person(person_info, Pet(\"Buddy\", 5))) |> print\n{\n  \"info\":{\n    \"marks\":[\n      \"A+\",\n      \"B\",\n      \"A\"\n    ],\n    \"id\":42\n  },\n  \"pet\":{\n    \"name\":\"Buddy\",\n    \"age\":5\n  }\n}\n\n\n\n\n\n","category":"function"},{"location":"pages/yaml/#YAML","page":"YAML","title":"YAML","text":"","category":"section"},{"location":"pages/yaml/#Parsing","page":"YAML","title":"Parsing","text":"","category":"section"},{"location":"pages/yaml/","page":"YAML","title":"YAML","text":"Serde.parse_yaml\nSerde.YamlSyntaxError","category":"page"},{"location":"pages/yaml/#Serde.ParYaml.parse_yaml","page":"YAML","title":"Serde.ParYaml.parse_yaml","text":"parse_yaml(x::AbstractString; kw...) -> Dict{String,Any}\nparse_yaml(x::Vector{UInt8}; kw...) -> Dict{String,Any}\n\nParse a YAML string x (or vector of UInt8) into a dictionary.\n\nKeyword arguments\n\nYou can see additional keyword arguments in YAML.jl package repository.\n\nExamples\n\njulia> yaml = \"\"\"\n        string: qwerty\n        date: 2024-01-01\n        dict:\n          dict_key_1: dict_value_1 #comment\n          dict_key_2: dict_value_2\n        list:\n          - string: foo\n            quoted: 'bar'\n            float: 1.63\n            int: 63\n          - string: baz\n            braces: '{{ dd }}'\n        anchorTest: &myAnchor\n          toSingleLine: >\n            this text will be considered on a\n            single line\n          toMultiline: |\n            this text will be considered\n            on multiple lines\n        aliasTest: *myAnchor\n        \"\"\";\n\njulia> parse_yaml(yaml)\nDict{String, Any} with 6 entries:\n  \"dict\"       => Dict{String, Any}(\"dict_key_2\"=>\"dict_value_2\", \"dict_key_1\"=>\"dict_value_1\")\n  \"string\"     => \"qwerty\"\n  \"list\"       => Dict{String, Any}[Dict(\"int\"=>63, \"string\"=>\"foo\", \"quoted\"=>\"bar\", \"float\"=>1.63), Dict(\"string\"=>\"baz\", \"braces\"=>\"{{ dd }}\")]\n  \"anchorTest\" => Dict{String, Any}(\"toMultiline\"=>\"this text will be considered \\non multiple lines\\n\", \"toSingleLine\"=>\"this text will be considered on a single line\\n\")\n  \"aliasTest\"  => Dict{String, Any}(\"toMultiline\"=>\"this text will be considered \\non multiple lines\\n\", \"toSingleLine\"=>\"this text will be considered on a single line\\n\")\n  \"date\"       => Date(\"2024-01-01\")\n\n\n\n\n\n","category":"function"},{"location":"pages/yaml/#Serde.ParYaml.YamlSyntaxError","page":"YAML","title":"Serde.ParYaml.YamlSyntaxError","text":"YamlSyntaxError <: Exception\n\nException thrown when a parse_yaml fails due to incorrect YAML syntax or any underlying error that occurs during parsing.\n\nFields\n\nmessage::String: The error message.\nexception::Exception: The catched exception.\n\n\n\n\n\n","category":"type"},{"location":"pages/yaml/#Deserialization","page":"YAML","title":"Deserialization","text":"","category":"section"},{"location":"pages/yaml/","page":"YAML","title":"YAML","text":"Serde.deser_yaml","category":"page"},{"location":"pages/yaml/#Serde.DeYaml.deser_yaml","page":"YAML","title":"Serde.DeYaml.deser_yaml","text":"deser_yaml(::Type{T}, x) -> T\n\nCreates a new object of type T and fill it with values from YAML formated string x (or vector of UInt8).\n\nKeyword arguments kw is the same as in parse_yaml.\n\nExamples\n\njulia> struct Status\n           id::Int64\n           value::Float64\n       end\n\njulia> struct Server\n           name::String\n           status::Status\n           data::Vector\n           online::Bool\n           users::Dict{String,Int64}\n       end\n\njulia> yaml = \"\"\"\n       name: cloud_server\n       status:\n         id: 42\n         value: 12.34\n       data:\n         - 1\n         - 2\n         - 3\n       online: True\n       users:\n         Kevin: 1\n         George: 2\n       \"\"\";\n\njulia> deser_yaml(Server, yaml)\nServer(\"cloud_server\", Status(42, 12.34), [1, 2, 3], true, Dict(\"Kevin\" => 1, \"George\" => 2))\n\n\n\n\n\n","category":"function"},{"location":"pages/yaml/#Serialization","page":"YAML","title":"Serialization","text":"","category":"section"},{"location":"pages/yaml/","page":"YAML","title":"YAML","text":"Serde.to_yaml","category":"page"},{"location":"pages/yaml/#Serde.SerYaml.to_yaml","page":"YAML","title":"Serde.SerYaml.to_yaml","text":"to_yaml([f::Function], data) -> String\n\nSerializes any data into a YAML multiline string. This method support serialization of nested data like dictionaries or custom types.\n\nSpecifying fields for serialization\n\nIf you want to serialize only specific fields of some custom type, you may define a special function f. This function f must lead next signature:\n\nf(::Type{CustomType}) = (:field_1, :field_2, ...)\n\nNow to_yaml(f, CustomType(...)) will serialize only specified fields CustomType.field_1, CustomType.field_2, etc. You can also define multiple methods of f for nested custom data types, e.g:\n\n# Custom type 'Foo' containing fields of other custom types 'bar::Bar' and 'baz::Baz'\ncustom_field_names(::Type{Foo}) = (:bar, :baz, ...)\n\n# Another custom types\ncustom_field_names(::Type{Bar}) = (:data, ...)\ncustom_field_names(::Type{Baz}) = (:another_data, ...)\n\nExamples\n\njulia> struct Pet\n           name::String\n           age::Int64\n       end\n\njulia> struct Person\n           info::Dict{String,Any}\n           pet::Pet\n       end\n\njulia> person_info = Dict(\"id\" => 42, \"marks\" => [\"A+\", \"B\", \"A\"]);\n\njulia> to_yaml(Person(person_info, Pet(\"Buddy\", 5))) |> print\ninfo:\n  marks:\n    - \"A+\"\n    - \"B\"\n    - \"A\"\n  id: 42\npet:\n  name: \"Buddy\"\n  age: 5\n\n\nNow, lets select some specific fields from custom type\n\njulia> struct ManyFields\n           field::Int64\n           another_field::Float64\n           simple_field::String\n           fld::Vector{Bool}\n       end\n\njulia> custom_field_names(::Type{ManyFields}) = (:field, :simple_field)\n\njulia> to_yaml(custom_field_names, ManyFields(1, 2.0, \"a\", [true, false])) |> print\nfield: 1\nsimple_field: \"a\"\n\n# Or you can use a lambda function\n\njulia> to_yaml(x -> (:field, :simple_field), ManyFields(1, 2.0, \"a\", [true, false])) |> print\nfield: 1\nsimple_field: \"a\"\n\n\n\n\n\n","category":"function"},{"location":"pages/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"pages/utils/","page":"Utils","title":"Utils","text":"Serde.to_flatten\nSerde.@serde\nSerde.@serde_pascal_case\nSerde.@serde_camel_case\nSerde.@serde_kebab_case","category":"page"},{"location":"pages/utils/#Serde.to_flatten","page":"Utils","title":"Serde.to_flatten","text":"Serde.to_flatten(data; delimiter = \"_\") -> Dict{String, Any}\n\nTransforms a nested dictionary data (or custom type) into a single-level dictionary. The keys in the new dictionary are created by joining the nested keys (or fieldnames) with delimiter symbol.\n\nExamples\n\nFlatten the nested dictionary with custom delimiter symbol.\n\njulia> nested_dict = Dict(\n       \"foo\" => 1,\n       \"bar\" => Dict(\n           \"foo\" => 2,\n           \"baz\" => Dict(\n              \"foo\" => 3,\n               ),\n           ),\n       );\n\njulia> Serde.to_flatten(nested_dict; delimiter = \"__\")\nDict{String, Any} with 3 entries:\n  :bar__baz__foo => 3\n  :foo           => 1\n  :bar__foo      => 2\n\nFlatten the nested structure.\n\njulia> struct Bar\n           num::Float64\n       end\n\njulia> struct Foo\n           val::Int64\n           str::String\n           bar::Bar\n       end\n\njulia> nested_struct = Foo(1, \"a\", Bar(1.0));\n\njulia> Serde.to_flatten(nested_struct)\nDict{String, Any} with 3 entries:\n  :bar_num => 1.0\n  :val   => 1\n  :str   => \"a\"\n\n\n\n\n\n","category":"function"},{"location":"pages/utils/#Serde.@serde","page":"Utils","title":"Serde.@serde","text":"@serde decorators... typedef\n\nHelper macro that implements user friendly configuration of the (de)serialization process (see extended deserialization and serialization). Available decorators:\n\n@default_value: Used to define default values for fields of declared type (see Serde.default_value).\n@de_name: Used to defines an alias names for fields of declared type (see Serde.custom_name).\n@ser_name: Used to define custom output name for fields of declared type (see Serde.ser_name).\n\nNext, the syntax template looks like this:\n\n@serde @decor_1 @decor_2 ... struct\n    var::T | val_1 | val_2 | ...\n    ...\nend\n\nAny combination of available decorators is valid. Decorators must be placed between @serde and struct keyword. Decorator values belonging to a certain field must be separated by the | symbol.\n\nExamples\n\n@serde @default_value @de_name @ser_name mutable struct Foo\n    bar::Int64 | 1 | \"first\" | \"bar\"\n    baz::Int64 | 2 | \"baz\"   | \"second\"\nend\n\nIf we do not specify any value, it will be taken from the column corresponding to @default_value. Notice that bar was initialised with default 1.\n\njulia> deser_json(Foo, \"\"\"{\"baz\": 20}\"\"\")\nFoo(1, 20)\n\nAlso, now names from the @de_name column will be used for deserialization.\n\njulia> deser_json(Foo, \"\"\"{\"first\": 30}\"\"\")\nFoo(30, 2)\n\nNames from the @ser_name column will be used as output names for serialization.\n\njulia> to_json(Foo(40, 50)) |> print\n{\"bar\":40,\"second\":50}\n\n\n\n\n\n","category":"macro"},{"location":"pages/utils/#Serde.@serde_pascal_case","page":"Utils","title":"Serde.@serde_pascal_case","text":"@serde_pascal_case T\n\nMarks all fields of type T with custom names corresponding to PascalCase.\n\nnote: Note\nField names of type T must match snake_case.\n\nSee also Serde.custom_name\n\nExamples\n\njulia> struct MySnakes\n           red_snake::Int64\n       end\n\njulia> @serde_pascal_case MySnakes\n\njulia> Serde.deser(MySnakes, Dict(\"RedSnake\" => 1))\nMySnakes(1)\n\n\n\n\n\n","category":"macro"},{"location":"pages/utils/#Serde.@serde_camel_case","page":"Utils","title":"Serde.@serde_camel_case","text":"@serde_camel_case T\n\nMarks all fields of type T with custom names corresponding to camelCase.\n\nnote: Note\nField names of type T must match snake_case.\n\nSee also Serde.custom_name\n\nExamples\n\njulia> struct MySnakes\n           forest_snake::Int64\n       end\n\njulia> @serde_camel_case MySnakes\n\njulia> Serde.deser(MySnakes, Dict(\"forestSnake\" => 2))\nMySnakes(2)\n\n\n\n\n\n","category":"macro"},{"location":"pages/utils/#Serde.@serde_kebab_case","page":"Utils","title":"Serde.@serde_kebab_case","text":"@serde_kebab_case T\n\nMarks all fields of type T with custom names corresponding to kebab-case.\n\nnote: Note\nField names of type T must match snake_case.\n\nSee also Serde.custom_name\n\nExamples\n\njulia> struct MySnakes\n           pretty_snake::Int64\n       end\n\njulia> @serde_kebab_case MySnakes\n\njulia> Serde.deser(MySnakes, Dict(\"pretty-snake\" => 3))\nMySnakes(3)\n\n\n\n\n\n","category":"macro"},{"location":"#Serde.jl","page":"Home","title":"Serde.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Serde is a Julia library for (de)serializing data to/from various formats. The library offers a simple and concise API for defining custom (de)serialization behavior for user-defined types. Inspired by the serde.rs Rust library, it supports the following data formats:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<html>\n  <body>\n    <table>\n      <tr><th>Format</th><th><div align=center>JSON</div></th><th><div align=center>TOML</div></th><th><div align=center>XML</div></th><th><div align=center>YAML</div></th><th><div align=center>CSV</div><th><div align=center>Query</div></th><th><div align=center>MsgPack</div></th><th><div align=center>BSON</div></th></tr>\n      <tr>\n        <td>Deserialization</td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>(planned)</div></td>\n        <td><div align=center>(planned)</div></td>\n      </tr>\n      <tr>\n        <td>Serialization</td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>✓</div></td>\n        <td><div align=center>(planned)</div></td>\n        <td><div align=center>(planned)</div></td>\n      </tr>\n    </table>\n  </body>\n</html>","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Serde, simply use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add Serde","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's look at some of the most used cases","category":"page"},{"location":"#Deserialization","page":"Home","title":"Deserialization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following is an example of how you can deserialize various formats, like JSON, TOML, Query and CSV into a custom structure JuliaCon. The deserialization process was also modified to correctly process start_date and end_date by adding the method Serde.deser","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates, Serde\n\n# Define a struct to hold JuliaCon information\nstruct JuliaCon\n    title::String\n    start_date::Date\n    end_date::Date\nend\n\n# Custom deserialization function for the JuliaCon struct\nfunction Serde.deser(::Type{JuliaCon}, ::Type{Date}, v::String)\n    return Dates.Date(v, \"U d, yyyy\")\nend\n\n# JSON deserialization example\njson = \"\"\"\n{\n  \"title\": \"JuliaCon 2024\",\n  \"start_date\": \"July 9, 2024\",\n  \"end_date\": \"July 13, 2024\"\n}\n\"\"\"\n\n# Deserialize JSON to a JuliaCon object\njulia> juliacon = deser_json(JuliaCon, json)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-09\"), Date(\"2024-07-13\"))\n\n# TOML deserialization example\ntoml = \"\"\"\ntitle = \"JuliaCon 2024\"\nstart_date = \"July 9, 2024\"\nend_date = \"July 13, 2024\"\n\"\"\"\n\n# Deserialize TOML to a JuliaCon object\njulia> juliacon = deser_toml(JuliaCon, toml)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-09\"), Date(\"2024-07-13\"))\n\n# URL query string deserialization example\nquery = \"title=JuliaCon 2024&start_date=July 9, 2024&end_date=July 13, 2024\"\n\n# Deserialize query string to a JuliaCon object\njulia> juliacon = deser_query(JuliaCon, query)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-09\"), Date(\"2024-07-13\"))\n\n# CSV deserialization example\ncsv = \"\"\"\ntitle,start_date,end_date\n\"JuliaCon 2024\",\"July 9, 2024\",\"July 13, 2024\"\n\"\"\"\n\n# Deserialize CSV to a vector of JuliaCon objects\njulia> juliacon = deser_csv(JuliaCon, csv)\n1-element Vector{JuliaCon}:\n JuliaCon(\"JuliaCon 2024\", Date(\"2024-07-09\"), Date(\"2024-07-13\"))\n\n# YAML deserialization example\nyaml = \"\"\"\n---\ntitle: JuliaCon 2024\nstart_date: 2024-07-09\nend_date: 2024-07-13\n\"\"\"\n\n# Deserialize YAML to a JuliaCon object\njulia> juliacon = deser_yaml(JuliaCon, yaml)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-09\"), Date(\"2024-07-13\"))\n\n# XML deserialization example\nxml = \"\"\"\n<xml title=\"JuliaCon 2024\" start_date=\"July 9, 2024\" end_date=\"July 13, 2024\" />\n\"\"\"\n\n# Deserialize XML to a JuliaCon object\njulia> juliacon = deser_xml(JuliaCon, xml)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-09\"), Date(\"2024-07-13\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to see more deserialization options, then take a look at the corresponding section of the documentation","category":"page"},{"location":"#Serialization","page":"Home","title":"Serialization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following example shows how an object juliacon of custom type JuliaCon can be serialized into various formats, like JSON, TOML, XML, etc. In that case, all dates will be correctly converted into strings of the required format by overloaded function ser_type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates, Serde\n\n# Define the struct to hold the JuliaCon conference details\nstruct JuliaCon\n    title::String\n    start_date::Date\n    end_date::Date\nend\n\n# Create an instance of JuliaCon with the specified details\njuliacon = JuliaCon(\"JuliaCon 2024\", Date(2024, 7, 9), Date(2024, 7, 13))\n\n# Define serialization for JuliaCon struct to JSON format\nfunction Serde.SerJson.ser_type(::Type{JuliaCon}, v::Date)\n    return Dates.format(v, \"U d, yyyy\")\nend\n\n# Serialize the JuliaCon instance to JSON and print it\njulia> to_json(juliacon) |> print\n{\"title\":\"JuliaCon 2024\",\"start_date\":\"July 9, 2024\",\"end_date\":\"July 13, 2024\"}\n\n# Define serialization for JuliaCon struct to TOML format\nfunction Serde.SerToml.ser_type(::Type{JuliaCon}, v::Date)\n    return Dates.format(v, \"yyyy-mm-dd\")\nend\n\n# Serialize the JuliaCon instance to TOML and print it\njulia> to_toml(juliacon) |> print\ntitle = \"JuliaCon 2024\"\nstart_date = \"2024-07-09\"\nend_date = \"2024-07-13\"\n\n# Define serialization for JuliaCon struct to XML format\nfunction Serde.SerXml.ser_type(::Type{JuliaCon}, v::Date)\n    return Dates.format(v, \"yyyy-mm-dd\")\nend\n\n# Serialize the JuliaCon instance to XML and print it\njulia> to_xml(juliacon) |> print\n<xml title=\"JuliaCon 2024\" start_date=\"2024-07-09\" end_date=\"2024-07-13\"/>\n\n# Define serialization for JuliaCon struct to YAML format\nfunction Serde.SerJson.ser_type(::Type{JuliaCon}, v::Date)\n    return Dates.format(v, \"U d, yyyy\")\nend\n\n# Serialize the JuliaCon instance to YAML and print it\njulia> to_yaml(juliacon) |> print\ntitle: \"JuliaCon 2024\"\nstart_date: \"2024-07-09\"\nend_date: \"2024-07-13\"\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to see more serialization options, then take a look at the corresponding section of the documentation","category":"page"},{"location":"#User-friendly-(de)serialization","page":"Home","title":"User friendly (de)serialization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"That's not all, work is currently underway on macro functionality that allows for more fine-grained and simpler customization of the (de)serialization process. You can choose from various available decorators that will allow you to unleash all the possibilities of Serde. More information can be found in the documentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates, Serde\n\n@serde @default_value @de_name struct JuliaCon\n    title::String    | \"JuliaCon 2024\"   | \"title\"\n    start_date::Date | nothing           | \"start\"\n    end_date::Date   | Date(2024, 7, 24) | \"end\"\nend\n\n# Custom deserialization function for the JuliaCon struct\nfunction Serde.deser(::Type{JuliaCon}, ::Type{Date}, v::String)\n    return Dates.Date(v)\nend\n\n# Deserialization from JSON example\njson = \"\"\"{\"title\": \"JuliaCon 2024\", \"start\": \"2024-07-22\"}\"\"\"\n\njulia> juliacon = deser_json(JuliaCon, json)\nJuliaCon(\"JuliaCon 2024\", Date(\"2024-07-22\"), Date(\"2024-07-24\"))\n\njulia> to_json(juliacon) |> print\n{\"title\":\"JuliaCon 2024\",\"start_date\":\"2024-07-22\",\"end_date\":\"2024-07-24\"}","category":"page"},{"location":"pages/extended_de/#ex_deser","page":"Extended deserialization","title":"Extended deserialization","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Serde.jl allows users to define how their custom data will be processed during deserialization.","category":"page"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Serde.deser(::Type, ::Any)","category":"page"},{"location":"pages/extended_de/#Serde.deser-Tuple{Type, Any}","page":"Extended deserialization","title":"Serde.deser","text":"Serde.deser(::Type{T}, data) -> T\n\nMain function of this module which can construct an object of type T from another object data. Can deserialize complex object with a deep nesting.\n\nFunction deser supports:\n\nDeserialization from Dict and Vector to Struct\nDeserialization from Dict and Vector to Vector of Struct\nDeserialization from Dict to Dict\nTypecasting during deserialization\nDefault value for struct arguments (see Serde.default_value)\nCustom name for struct arguments (see Serde.custom_name)\nEmpty type definition (see Serde.isempty)\nDeserializing missing and nothing (see Serde.nulltype)\n\nExamples:\n\njulia> struct Info\n           id::Int64\n           salary::Int64\n       end\n\njulia> struct Person\n           name::String\n           age::Int64\n           info::Info\n       end\n\njulia> info_data = Dict(\"id\" => 12, \"salary\" => 2500);\n\njulia> person_data = Dict(\"name\" => \"Michael\", \"age\" => 25, \"info\" => info_data);\n\njulia> Serde.deser(Person, person_data)\nPerson(\"Michael\", 25, Info(12, 2500))\n\n\n\n\n\n","category":"method"},{"location":"pages/extended_de/#Custom-deserialization-behavior","page":"Extended deserialization","title":"Custom deserialization behavior","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"If you need to deserialize non-standard custom data types, it will be useful to define a behavior to handle them.","category":"page"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Serde.deser(::Type, ::Type, ::Any)","category":"page"},{"location":"pages/extended_de/#Serde.deser-Tuple{Type, Type, Any}","page":"Extended deserialization","title":"Serde.deser","text":"Serde.deser(::Type{T}, ::Type{E}, data::D) -> E\n\nInternal function that is used to deserialize data to fields with type E of custom type T. Supports user overriding for custom types.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nExamples:\n\nLet's make a custom type Order with fields price and date.\n\nusing Dates\n\nstruct Order\n    price::Int64\n    date::DateTime\nend\n\nNow, we define a new method Serde.deser for the custom type Order. This method will be called for each field of Order that is of type DateTime and has been passed a String value.\n\nfunction Serde.deser(\n    ::Type{T},\n    ::Type{E},\n    x::String\n)::E where {T<:Order,E<:DateTime}\n    return DateTime(x)\nend\n\nAfter that, if we try to deserialize a dictionary that has a key date with a String value, it will correctly convert the String to a DateTime value.\n\njulia> Serde.deser(Order, Dict(\"price\" => 1000, \"date\" => \"2024-01-01T10:20:30\"))\nOrder(1000, DateTime(\"2024-01-01T10:20:30\"))\n\n\n\n\n\n","category":"method"},{"location":"pages/extended_de/#Empty-values-handling","page":"Extended deserialization","title":"Empty values handling","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"We can also determine which data types and their values will be treated as nothing.","category":"page"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Serde.isempty","category":"page"},{"location":"pages/extended_de/#Base.isempty","page":"Extended deserialization","title":"Base.isempty","text":"Serde.isempty(::Type{T}, x) -> false\n\nThis function determines the condition under which the passed value x for some custom type T can be treated as nothing. Supports user overriding for custom types. Initially, all values are set to false.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nSee also Serde.nulltype, Serde.default_value.\n\nExamples:\n\nLet's make a custom type Computer with the following fields. The gpu field may be either a String or Nothing.\n\nstruct Computer\n    cpu::String\n    ram::Int64\n    gpu::Union{Nothing,String}\nend\n\nNow, we define a new method Serde.isempty for the custom type Computer. This method will be called for each field of Computer that has been passed a String value.\n\nfunction Serde.isempty(::Type{Computer}, x::String)\n    return x == \"\"\nend\n\nSo, if we try to deserialize a dictionary with a key gpu containing an empty string, it will set a nothing value for such a field in Computer.\n\njulia> Serde.deser(Computer, Dict(\"cpu\" => \"i7-12900\", \"ram\" => 32, \"gpu\" => \"rtx-4090\"))\nComputer(\"i7-12900\", 32, \"rtx-4090\")\n\njulia> Serde.deser(Computer, Dict(\"cpu\" => \"i3-12100\", \"ram\" => 16, \"gpu\" => \"\"))\nComputer(\"i3-12100\", 16, nothing)\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_de/#Names-aliases","page":"Extended deserialization","title":"Names aliases","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Sometimes, the field names of the incoming data structure differ from their intended destination. In this case, it is convenient to specify name aliases.","category":"page"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Serde.custom_name","category":"page"},{"location":"pages/extended_de/#Serde.custom_name","page":"Extended deserialization","title":"Serde.custom_name","text":"Serde.custom_name(::Type{T}, ::Val{x}) -> x\n\nThis function is used to define an alias name for field x of type T. Supports user overriding for custom types. Initially, all passed names must be equivalent to the target names. Methods of this function must return a Symbol or a String value.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nExamples:\n\nLet's make a custom type Phone with one field price.\n\nstruct Phone\n    price::Int64\nend\n\nNow, we can define a new method Serde.custom_name for the type Phone and its field price.\n\nfunction Serde.custom_name(::Type{Phone}, ::Val{:price})\n    return \"cost\"\nend\n\nAfter that, if we try to deserialize a dictionary with an alias key \"cost\", it will match with the field price of type Phone.\n\njulia> Serde.deser(Phone, Dict(\"cost\" => 1000))\nPhone(1000)\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_de/#Custom-default-values","page":"Extended deserialization","title":"Custom default values","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"We can also define default values for certain data types.","category":"page"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Serde.default_value","category":"page"},{"location":"pages/extended_de/#Serde.default_value","page":"Extended deserialization","title":"Serde.default_value","text":"Serde.default_value(::Type{T}, ::Val{x}) -> nothing\n\nThis function is used to define default values for field x of type T. Supports user overriding for custom types. Initially, all values are set to nothing.\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nSee also Serde.isempty, Serde.nulltype.\n\nExamples:\n\nLet's make a custom type TimeZone with the field gmt.\n\nstruct TimeZone\n    gmt::String\nend\n\nNow, we can define a new method Serde.default_value for the type TimeZone and its field gmt.\n\nfunction Serde.default_value(::Type{TimeZone}, ::Val{:gmt})\n    return \"UTC+3\"\nend\n\nAfter that, if we try to deserialize a dictionary without a key gmt, it will be filled with the default value \"UTC+3\".\n\njulia> Serde.deser(TimeZone, Dict{String,Any}())\nTimeZone(\"UTC+3\")\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_de/#Null-types-handling","page":"Extended deserialization","title":"Null types handling","text":"","category":"section"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Finally, we can determine the 'nulltype' for custom types when they are empty or not specified at all.","category":"page"},{"location":"pages/extended_de/","page":"Extended deserialization","title":"Extended deserialization","text":"Serde.nulltype","category":"page"},{"location":"pages/extended_de/#Serde.nulltype","page":"Extended deserialization","title":"Serde.nulltype","text":"Serde.nulltype(::Type{T}) -> nothing\n\nDefines behavior when the value for a field of type T is empty (according to Serde.isempty) or not specified. Supports user overriding for custom types. Initially, for all types, it is set to nothing (in case of type Missing, it returns the missing value).\n\nnote: Note\nThis function is not used explicitly and can only be overridden for the deserialization process.\n\nSee also Serde.isempty, Serde.default_value.\n\nExamples\n\nLet's make a custom type Computer with the following fields.\n\nstruct Computer\n    cpu::String\n    gpu::String\nend\n\nFor clarity, we also define the Serde.isempty method.\n\nSerde.isempty(::Type{Computer}, x::String) = x == \"\"\n\nNext, we define a new method Serde.nulltype for the custom type Computer. This method will be called for each type String that has been passed to a Serde.deser method.\n\nSerde.nulltype(::Type{String}) = \"N/A\"\n\nAnd, if we try to deserialize a dictionary with values of type String containing an empty string or not specified at all, it will set a \"N/A\" value for such fields in Computer.\n\njulia> Serde.deser(Computer, Dict(\"cpu\" => \"i7-12900\", \"gpu\" => \"\"))\nComputer(\"i7-12900\", \"N/A\")\n\njulia> Serde.deser(Computer, Dict{String,Any}())\nComputer(\"N/A\", \"N/A\")\n\n\n\n\n\n","category":"function"},{"location":"pages/extended_ser/#ex_ser","page":"Extended serialization","title":"Extended serialization","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Serde.jl users have the flexibility to customize the serialization process of their data.","category":"page"},{"location":"pages/extended_ser/#ser_name","page":"Extended serialization","title":"Changing output names","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"If you want to change the output names of your custom type, you just have to extend the Serde.<SubModule>.ser_name function. This approach is supported by the following serialization methods:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json (SerJson submodule).\nto_toml (SerToml submodule).\nto_query (SerQuery submodule).\nto_xml (SerXml submodule).\nto_yaml (SerYaml submodule).","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"The return value of your method must be of type Symbol or String. The default signature is:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"ser_name(::Type{T}, ::Val{x})::Symbol where {T,x} = x","category":"page"},{"location":"pages/extended_ser/#Example","page":"Extended serialization","title":"Example","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"For convenience, we import the necessary SerJson submodule.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"using Serde.SerJson","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Then, let's define a simple custom type Ticket.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"struct Ticket\n    cost::Int64\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Now, we can add a new method SerJson.ser_name for the custom type Ticket and its field cost.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"SerJson.ser_name(::Type{Ticket}, ::Val{:cost}) = :price","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"After that, in the resulting JSON string the field cost will become price.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"julia> to_json(Ticket(1000)) |> print\n{\"price\":1000}","category":"page"},{"location":"pages/extended_ser/#Handling-field-values","page":"Extended serialization","title":"Handling field values","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Also, we can specify how to process certain fields of custom types. In that case, you need extend the Serde.<SubModule>.ser_value function. This approach is supported by such serialization methods:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json (SerJson submodule).\nto_toml (SerToml submodule).\nto_query (SerQuery submodule).\nto_xml (SerXml submodule).\nto_yaml (SerYaml submodule).","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"The method can return a value of any type. The default signature is:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"ser_value(::Type{T}, ::Val{x}, v::V) where {T,x,V} = v","category":"page"},{"location":"pages/extended_ser/#Example-2","page":"Extended serialization","title":"Example","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"For convenience, we import the necessary SerJson submodule.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"using Dates\nusing Serde.SerJson","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Then, let's define a simple custom type Calendar.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"struct JuliaBirthday\n    date::DateTime\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"In the next line, we add a method SerJson.ser_value for the custom type JuliaBirthday and its field date of type DateTime.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"function SerJson.ser_value(::Type{JuliaBirthday}, ::Val{:date}, v::DateTime)\n    return Dates.value(Nanosecond(datetime2unix(v)))\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Now, we will obtain a nanosecond value of the field v.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"julia> to_json(JuliaBirthday(DateTime(2012, 2, 14))) |> print\n{\"date\":1329177600}","category":"page"},{"location":"pages/extended_ser/#Handling-values-of-specific-types","page":"Extended serialization","title":"Handling values of specific types","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"If you want to override how to serialize a specific type, you need extend the Serde.<SubModule>.ser_type function. This approach is supported by the following serialization methods:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json (SerJson submodule).\nto_toml (SerToml submodule).\nto_query (SerQuery submodule).\nto_xml (SerXml submodule).\nto_yaml (SerYaml submodule).","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"The method can return a value of any type. The default signature is:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"ser_type(::Type{T}, v::V) where {T,V} = v","category":"page"},{"location":"pages/extended_ser/#Example-3","page":"Extended serialization","title":"Example","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"For convenience, we import the necessary SerJson submodule.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"using Serde.SerJson","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Then, let's define a simple custom type Computer with two string fields.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"struct Computer\n    cpu::String\n    gpu::String\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"As well, we can add a method SerJson.ser_type for type Computer and all its fields of type String.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"SerJson.ser_type(::Type{Computer}, v::String) = uppercase(v)","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Now, every string field of Computer will be in uppercase.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"julia> to_json(Computer(\"i7-12900\", \"rtx-4090\")) |> print\n{\"cpu\":\"I7-12900\",\"gpu\":\"RTX-4090\"}","category":"page"},{"location":"pages/extended_ser/#Ignoring-fields","page":"Extended serialization","title":"Ignoring fields","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Finally, we can specify what fields must be ignored. In this case, you just need to extend the Serde.<SubModule>.ignore_field function. This approach is supported by the following serialization methods:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json (SerJson submodule).","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"The return value of your method must be of type Bool. The default signature is:","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"ignore_field(::Type{T}, ::Val{x})::Bool where {T,x} = false","category":"page"},{"location":"pages/extended_ser/#Example-4","page":"Extended serialization","title":"Example","text":"","category":"section"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"For convenience, we import the necessary submodule.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"using Serde.SerJson","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Then, let's define a simple custom type Box.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"struct Box\n    height::Int64\n    width::Int64\n    length::Int64\nend","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Let's add the SerJson.ignore_field method for type Box.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"SerJson.ignore_field(::Type{Box}, ::Val{:length}) = true","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"Because the field length is ignorable, the resulting JSON string contains only height and width values.","category":"page"},{"location":"pages/extended_ser/","page":"Extended serialization","title":"Extended serialization","text":"to_json(Box(2, 5, 6)) |> print\n{\"height\":2,\"width\":5}","category":"page"}]
}
